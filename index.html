<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>CS-217 Data Structures and Algorithms I</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.9 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>CS-217 Data Structures and Algorithms I</h1>
<p>
<h2><a class="anchor" name="student">
Student</a></h2>
R. Scott Linford<h2><a class="anchor" name="intro">
Introduction</a></h2>
This package contains an object oriented framework of data structures. In its last delivery it looked like:<p>
<div align="center">
<img src="original_class_hierarchy.png" alt="original_class_hierarchy.png">
<p><strong>Beginning Class Hierarchy</strong></p></div>
 <a class="el" href="classcontainer_1_1LinkedList.html" title="A mostly complete linked-list implementation of List.">LinkedList</a> was the only working structure. It had a base class called <a class="el" href="classcontainer_1_1OrderedList.html" title="An ADT that represents a list of items.">OrderedList</a>. Several other classes were stubbed in and formed the beginning of a class hierarchy with <a class="el" href="classcontainer_1_1Container.html" title="Abstract base class for all containers.">Container</a> as the one common super-class.<p>
The hierarchy has grown. Most of the classes in the package extend <a class="el" href="classcontainer_1_1Object.html" title="The root for most classes in the container namespace.">Object</a>.<p>
<div align="center">
<img src="final_class_hierarchy.png" alt="final_class_hierarchy.png">
<p><strong>Final Class Hierarchy</strong></p></div>
 The <a class="el" href="classcontainer_1_1Object.html" title="The root for most classes in the container namespace.">Object</a> super-class was originally created to generate output in a polymorphic manner. I'm used to Java in which all classes ultimately derive from a common super-class.<p>
All of the data structures are unbounded, including the array implementations which expand as needed. All structures use dynamic allocation.<p>
Two doubly-linked lists are implemented, one that maintains a sorted order and one that doesn't. The <a class="el" href="classcontainer_1_1SortedLinkedList.html" title="A linked list implementation of SortedList.">SortedLinkedList</a> does not except duplicates and the OrderedLinekList does. The common functionality to both linked lists resides in the abstract class <a class="el" href="classcontainer_1_1LinkedList.html" title="A mostly complete linked-list implementation of List.">LinkedList</a>. As the diagram shows, multiple inheritance is in use.<p>
Two array based lists are implemented, following the same pattern as the linked lists. Most of the common functionality between the two concrete classes resides in <a class="el" href="classcontainer_1_1ArrayList.html" title="A mostly complete array-list implementation of List.">ArrayList</a>. The <a class="el" href="classcontainer_1_1SortedArrayList.html" title="An array implementation of SortedList.">SortedArrayList</a> makes use of binary searching for retrieval and for insertion.<p>
The <a class="el" href="classcontainer_1_1Queue.html" title="Abstract base class for all queue containers.">Queue</a> and <a class="el" href="classcontainer_1_1Stack.html" title="Abstract base class for all stack containers.">Stack</a> implementation can be composed with either a <a class="el" href="classcontainer_1_1OrderedArrayList.html" title="An array list implementation of OrderedList.">OrderedArrayList</a> or and <a class="el" href="classcontainer_1_1OrderedLinkedList.html" title="A linked list implementation of OrderedList.">OrderedLinkedList</a>, using the factory methods provided. <a class="el" href="classcontainer_1_1QueueImpl.html" title="An implementation of Queue that based on an OrderedList.">QueueImpl</a> contains functionality that demonstrates the difference between deep and shallow copying.<p>
Unit tests have been refactored to take advantage of the polymorphic nature of the framework. As shown in the above diagram, for example, all list classes have a common parent called <a class="el" href="classcontainer_1_1List.html" title="Abstract base class for all list containers.">List</a> (oddly enough). There is a unit test called <a class="el" href="classcontainer__test_1_1List__test.html" title="Polymorphic code for testing concrete sub-classes of container::List.">container_test::List_test</a> that enforces the <a class="el" href="classcontainer_1_1List.html" title="Abstract base class for all list containers.">List</a> contract for all known sub-classes.<p>
<div align="center">
<img src="list_unit_test_hierarchy.png" alt="list_unit_test_hierarchy.png">
<p><strong>Final Class Hierarchy</strong></p></div>
 The unit tests became invaluable during the extensive refactoring. They caught a lot of bugs, and allowed me to make implementation chages with confidence. All I needed to see were the green lines at the bottom of the output I knew that the method contracts were still satisfied.<h2><a class="anchor" name="design">
Project Considerations</a></h2>
<h3><a class="anchor" name="opportunity">
Dusting Off the Old Skills</a></h3>
First of all, I haven't done any serious C++ work for 15 years. So this is a good excuse for me to relearn the language and research the new features and coding standards which have evolved during my absence. C++ templates give me a headache but I'll find some way to use them.<h3><a class="anchor" name="oo">
A Rough OO Outline</a></h3>
Second, I want to end up with an OO hierarchy of classes. From experience, I know how hard OO design is to do right. First guesses are always wrong. It usually requires an iterative process to discover abstractions and pull them up into a super class. I haven't started from scratch, however, having taken inspiration from the Java collections framework and other sources.<h3><a class="anchor" name="flexibility">
More Rope</a></h3>
Third, Java is an insidious language in its simplicity. All primitive types are passed by value and all user-created types are passed by reference. In Java there's no such thing as a struct residing on the call stack. Instead, the stack only has references to dynamically allocated objects on the heap. Now I'm back to C++ which has too many choices, all this flexibility, i.e., (rope to hang myself with).<p>
So, coming from a Java frame of mind, <a class="el" href="classcontainer_1_1Container.html" title="Abstract base class for all containers.">Container</a> classes will not make copies of the <a class="el" href="classcontainer_1_1Entity.html" title="The base class of all items that can be stored in a Container.">Entity</a> objects stored within them. Only copies of pointer values will be made when an <a class="el" href="classcontainer_1_1Entity.html" title="The base class of all items that can be stored in a Container.">Entity</a> is added. The <a class="el" href="classcontainer_1_1Container.html" title="Abstract base class for all containers.">Container</a> classes will take responsibility of deleting any <a class="el" href="classcontainer_1_1Entity.html" title="The base class of all items that can be stored in a Container.">Entity</a> objects they have a reference to at the time of <a class="el" href="classcontainer_1_1Container.html" title="Abstract base class for all containers.">Container</a> destruction.<h2><a class="anchor" name="output">
Functionality Demonstration</a></h2>
Output for demonstration is weaved into the unit tests.<p>
<div align="center">
<img src="unit_test_output.png" alt="unit_test_output.png">
<p><strong>Sample Output</strong></p></div>
 The unit test output starts with green text (or red for a failure). All the other lines were added to demonstrate that something is actually happening. The test cases are too verbose to easily capture in a screen shot. Here is the full text of the current output:<p>
<a href="../Engineering/artifacts/unit_test_output_4-6-2009.txt">LinkedList and Entity - Unit Test Output</a><p>
The unit tests verify and assert more than is being reported in the print statements. For example, two methods from LinkedList_test generated the above output:<p>
<div align="center">
<img src="linkedlist_example_test_code.png" alt="linkedlist_example_test_code.png">
</div>
<p>
Normally, unit tests aren't designed for human eyes. They either pass or fail, much like code compilation which either succeeds or fails.<p>
Well written unit tests do not require print statements. When they fail, the output is designed to be sufficient to trace the problem to its source. The googletest framework is good in this respect. Upon failure, it prints line numbers, expected values, actual values, etc, that make print statements superfluous in a real development environment.<h2><a class="anchor" name="env">
Development Environment</a></h2>
<h3><a class="anchor" name="automation">
I Want My IDE Back</a></h3>
Coming from a Java background, I've attempted to replicate the features found in IDE's like Eclipse and NetBeans. Long ago I had done C and C++ from the command line using tools like vi, make, etc. But now I'm spoiled. I've grown accustomed to code completion, incremental compilation, dependable refactoring tools, and other productivity aids.<p>
For example, with NetBeans you can create a Hello World program with a few clicks and then run it by pressing the big green arrow. This is true for a simple console application, a GUI desktop application, a web application, etc. For a web application, it fires up the web server for you a and pops open a browser running the new code, all with the friendly green arrow. Just press play.<p>
Unit tests are just as easy, right out of the box. Select the class to be tested and NetBeans generates a JUnit class with a stub for each method. All you have to do is fill in the stubs. Unit tests can be run with a click of the mouse and become a natural part of the build process.<h3><a class="anchor" name="svn">
Source Control</a></h3>
Another requirement I set for my environment was to continue using Subversion as my code repository. NetBeans integrates with Subversion. The files shown in blue (<a class="el" href="container_8h.html" title="Header file for class container::Container.">container.h</a> and Doxyfile) have been locally modified:<p>
<div align="center">
<img src="project_trees.png" alt="project_trees.png">
</div>
<p>
I started using Subversion for CS-114. Access to source code is served up via HTTP from my laptop computer. I have a development environment at home and at work, which serves as protection against loss and forces me to check in code frequently. In doing so, I have a full history of my project since its inception, with useful check-in comments about what was changed any why.<p>
<div align="center">
<img src="sample_history_for_linkedlist_h.png" alt="sample_history_for_linkedlist_h.png">
</div>
<p>
The NetBeans integration allows for each line to be traced back to the responsible developer and the revision where the line was last changed. This is not a special read-only view. The following shot is of "live" editable code:<p>
<div align="center">
<img src="annotated_code_userid_and_version.png" alt="annotated_code_userid_and_version.png">
<p><strong>Annotated Code With UserID and Version Number</strong></p></div>
 I experimented with Microsoft's Visual Studio. It has decent code refactoring but there is no built in support for Subversion. Agent SVN looks like a nice plug-in, but $95.95 was not in the budget.<h3><a class="anchor" name="netbeans">
NetBeans and C++?</a></h3>
So after additional research I decided to stick with NetBeans which has a C++ plug-in (crazy). NetBeans becomes a shell for the standard GNU set of tools (gcc, g++, gdb, make, etc.) which have been ported to Cygwin (a Unix-like environment for Windows).<p>
It took me a long time to get NetBeans to compile and run a simple program, partly because it has been so long since I have had to worry about include files, linking, and other concerns that either don't exist in Java or are taken care of by the toolset. Yes, I know, I've grown soft. The first linking error really took me back to the old days, "Oh yeah, these. My favorite."<h3><a class="anchor" name="googletest">
Unit Test Framework</a></h3>
Then I went in search of a C++ unit-test framework and found that there isn't a de facto standard like JUnit is for the Java world. I settled on googletest because it has the ability to auto-discover unit tests. I downloaded the googletest source code and built it under Cygwin. With scanty documentation it took some time to figure out how to set it up.<p>
I ended up with two NetBeans projects. "Structures" for the actual code and "Structures_test" for the unit tests. The source code in "Structures" has no dependency on the unit tests. It compiles down to a library called "libstructures.a" (no executable).<p>
Project "Structures_test" has a build dependency on "Structures". So with a click of a button all files are compiled, linked, and unit tests are executed. The magic is performed by Google's "gtest_main.a" which has a main function that does the work of finding and executing all unit tests.<h3><a class="anchor" name="doxygen">
Automatic API Documentation</a></h3>
Then I had to have automatic documentation. I'm spoiled, remember? In NetBeans (yes, you guessed it) you click a menu and the Javadoc shows up in a browser. For this project I'm learning Doxygen. To automate the process I added a new target to the Makefile that NetBeans generated. My make utility skills were very rusty.<h2><a class="anchor" name="works">
Sources and Other Inspiration</a></h2>
I started the class without the textbook. It took longer than expected to arrive. I turned to other sources, including Java's collection framework which I have used for years.<p>
I also came across an online text book, "Data Structures and Algorithms with Object-Oriented Design Patterns in C++", by Bruno R. Preiss. It has snippets of code but the source is not available.<p>
<ul>
<li>Opus5 (the Java version of the textbook)<ul>
<li>Java version of the text.</li><li>Includes Javadoc of Preiss' data structure framework</li><li>Javadoc:<ul>
<li><a href="http://www.brpreiss.com/books/opus5/javadoc/index.html">http://www.brpreiss.com/books/opus5/javadoc/index.html</a></li></ul>
</li><li>Java source snippets:<ul>
<li><a href="http://www.brpreiss.com/books/opus5/programs/index.html">http://www.brpreiss.com/books/opus5/programs/index.html</a></li></ul>
</li></ul>
</li><li>Opus4 (the C++ version of the textbook)<ul>
<li>C++ textbook:<ul>
<li><a href="http://www.brpreiss.com/books/opus4/">http://www.brpreiss.com/books/opus4/</a></li></ul>
</li><li>Class hierarchy diagram<ul>
<li><a href="http://www.brpreiss.com/books/opus4/html/page617.html#SECTION0019000000000000000000">http://www.brpreiss.com/books/opus4/html/page617.html#SECTION0019000000000000000000</a> </li></ul>
</li></ul>
</li></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Jun 16 23:12:44 2009 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.9 </small></address>
</body>
</html>
